как измерять скорость алгоритма 
require "benchmark"
time = Benchmark.realtime do
	суперпупер алгоритм
end
puts time.round(2)
--------------------------
Отключение сбощика мусора
GC.disable
может дать 50% прирост скорости алгоритма

(RSS)Resident Set Size, размер резидентного набора - часть памяти процесса, которая хранится в ОЗУ.
Увидеть можно вставляя этот код
puts "%dM" % `ps -o rss= -p #{Process.pid}`.to_i
puts "%d MB" % (`ps -o rss= -p #{Process.pid}`.to_i/1024)

Потребление памяти и сборка мусора - одни из основных причин медленной работы Ruby. Надо сохранять меньше промежутояных результатов(императивный стиль). Меньше работы мусорщику.
======================================
Глова 2 Исправление общих проблемм с производительностью

GC#stat возвращает количество запусков GC

Добавить скорости в код:
- str.downcase прожорливей чем str.downcase!
- x += "bar" прожорливей чем x << "bar"
- data.map прожорливей data.map!
- File.readlines("data.csv") прожорливей File.read("data.csv")
- CSV.open("data.csv") на много прожорливей File.open("data.csv", "r") 

Следите за утечками памяти, вызванными обратными вызовами:
Каждый раз, когда вы создаете блок или обратный вызов Proc. Помните, что если вы где-то храните его, вы также сохраните ссылки на его контекст выполнения.

Здесь блоки конвертируются в Proc и жрут много
def take_block(&block)
	block.call(args)
end
take_block { |args| do_something(args) }
менее затратно явно вызывать
def take_block
	yield(args)
end
take_block { |args| do_something(args) }

Оптимизируйте свои итераторы:
Ruby GC не будет собирать мусор для объекта, который вы повторяете, до того, как итератор завершит работу.
Итераторы будут создавать временные объекты. Это добавляет работы сборщику мусора и снижает производительность.

Вместо each можно пользовать while list.count > 0 c одновременным удалением item = list.shift

Использование Each! шаблона
class Array
	def each!
		while count > 0
			yield(shift)
		end
	end
end

Избегайте итераторов, создающих дополнительные объекты
Вложеные циклы тем более прожорливее чем больше уровней и ключей. each_index легче чем each_with_index

Парсинг даты в Ruby традиционно был медленным. Лучше явно передавать в дату формат, например,  Date.strptime(date, '%Y-%m-%d')

Object#class, Object#is_a?, Object#kind_of?
Рекомендуется отодвинуть проверку типов от итераторов или часто вызываемых функций и операторов.

BigDecimal == String
Такой код часто создает BigDecimal из строки, которую он считывает из базы данных, а затем сравнивает ее напрямую со строками. Преобразование BigDecimal в строку перед сравнением в три-четыре раза добавит скорости.

Разгрузка работы в базе данных:
Производительность вычислений PostgreSQL в десять раз выше, чем у Ruby.
select department_id, employee_id, salary,
  rank() over(partition by department_id order by salary desc)
from empsalaries;
*Функция generate_series, специфичная для Postgres

Перепишите на C
Есть много гемов Ruby, написанных на C, которые выполняют свою работу быстрее, чем их аналоги.













