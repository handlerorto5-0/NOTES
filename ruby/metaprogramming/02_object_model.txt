obj = MyClass.new
obj.methods.grep(/my/) ишет список методов

Коротко и ясно, о методах инстанса и методах класса:
String.instance_methods == "abc".methods  # => true
String.methods == "abc".methods           # => false

переменные экземпляра объекта живут в самом объекте, а методы объекта живут в классе объекта. Вот почему объекты одного класса используют общие методы, но не разделяют переменные экземпляра

сами классы не что иное, как объекты

"hello".class  # => String
String.class  # => Class
Class.instance_methods(false) # => [:allocate, :new, :superclass]

Array.superclass  # => Object
Object.superclass  # => BasicObject
BasicObject.superclass  # => nil
--------------------------------------
Class.superclass  # => Module
--------------------------------------
Любая ссылка, которая начинается с заглавной буквы, включая имена классов и модулей, является константой.
my_class = MyClass
MyClass и my_class являются ссылками на один и тот же экземпляр класса, с той лишь разницей, что my_class - это переменная, а MyClass - константа.

константы вложены как каталоги и файлы
module M
	class C
		X = 'a constant'
	end
	C::X # => "a constant"
end
M::C::X # => "a constant"
-----------------------------------------
load('motd.rb', true)
Если вы загрузите файл таким образом, Ruby создаст анонимный модуль
-----------------------------------------
-----------------------------------------
Что происходит, когда вы вызываете метод?

Когда вы вызываете метод, Ruby делает две вещи:
1. Находит метод. Это процесс, называемый поиском метода.
2. Выполняет метод. Для этого Ruby нужно что-то под названием self.

Получатель(receiver) - это объект, для которого вы вызываете метод. Например, если вы напишете my_string.reverse(), тогда my_string будет получателем.
Цепочка предков(ancestors chain) - переход от класса к его суперклассу, затем к суперклассу суперкласса и так далее, пока не достигнете BasicObject, корня иерархии классов Ruby

MySubclass.ancestors
---------------------------------
Цепочка предков для Модулей.

Когда вы включаете(include) модуль в класс (или даже в другой модуль), Ruby вставляет модуль в цепочку предков прямо над самим включающим классом:

module M1
	def my_method
	 'M1#my_method()'
	end
end
class C
	include M1
end
class D < C; end
D.ancestors # => [D, C, M1, Object, Kernel, BasicObject]

Метод добавления(prepend) вставляет модуль ниже включающего класса:

class C2
	prepend M2
end
class D2 < C2; end
D2.ancestors # => [D2, M2, C2, Object, Kernel, BasicObject]

Руби по умолчвнию игнорирует повторное включение при построении цепочки наследования.

------------------------------------------
Ядро(Kernel)
Ruby включает некоторые методы, такие как print, которые вы можете вызывать из любого места вашего кода.
Kernel.private_instance_methods.grep(/^pr/) # => [:printf, :print, :proc]

Уловка здесь в том, что класс Object включает ядро, поэтому ядро попадает в цепочку предков каждого объекта. Каждая строка Ruby всегда выполняется внутри объекта, поэтому вы можете вызывать методы экземпляра в ядре из любого места. Это создает иллюзию того, что print - это ключевое слово языка, хотя на самом деле это метод.
Вы можете воспользоваться этим механизмом самостоятельно: если вы добавите метод в ядро, этот метод ядра будет доступен для всех объектов.
==========================================
Выполнение метода.

Каждая строка кода Ruby выполняется внутри объекта - так называемого текущего объекта(current object). Текущий объект также известен как self, потому что вы можете получить к нему доступ с помощью ключевого слова self.
Только один объект может играть роль self в данный момент времени, но ни один объект не выполняет эту роль в течение длительного времени. В частности, когда вы вызываете метод, получатель становится self.

self # => main
self.class # => Object
---------------------------------
Переопределение внутри модуля
module StringExtensions
	refine String do
		def reverse
			"esrever"
		end
	end
end
module StringStuff
	using StringExtensions
	"my_string".reverse # => "esrever"
end
"my_string".reverse # => "gnirts_ym"
--------------------------------
Клубок модулей




















