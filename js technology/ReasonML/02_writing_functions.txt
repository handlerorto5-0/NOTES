========================================
Глава 2 Пишем функции стр 15

ReasonML требует, чтобы вы определяли свои функции перед их использованием.

let avg = (a, b) => {
	(a +. b) /. 2.0;
};
let result = avg(3.0, 4.5);
Js.log(result);

для компиляции функций:
вначале , создаст lib:
$ bsb -make-world
потом можно:
yarn build
--------------------------------------------
количество знаков после запятой, для переменной amount:
Js.Float.toFixedWithPrecision(amount, ~digits=2)
--------------------------------------------
Использование помеченных параметров(Labeled Parameters)

Позволяют передавать аргументы в любом порядке, с таким синтаксисом:
в функции определяем, "p" можно применят внутри функции:
let payment = (~principal as p, ~apr, ~years) => {..};
let amount = payment(~apr=7.5, ~years=15, ~principal=25000.0);
--------------------------------------------
Предоставление значений по умолчанию для помеченных параметров

Определяем:
let payment = (~principal, ~apr, ~years=30, ()) => { ...};
Применяем значение по умолчанию:
let amount = payment(~principal=10000.0, ~apr=5.0, ());
Или присваиваем другое значение:
let amount2 = payment(~apr=7.5, ~years=15, ~principal=25000.0, ());
----------------------------------------
Сокращение кода с помощью refmt

Не нужны скобки, когда всего один параметр:
let sqr = x => x * x;

С библиотекой bsrefmt, можно автоматически переформатировать код:
$ bsrefmt src/Functions.re > src/ReformattedFunctions.re

Последние две строки эквивалентны:
let apr = 7.5;
let principal = 10000.0;
let month1 = payment(~principal=principal, ~apr=apr, ~years=15, ());
let month2 = payment(~principal, ~apr, ~years=15, ());

Можно сделать длиное выражение короче:
let toFixed = Js.Float.toFixedWithPrecision;
let example = toFixed(3.1415926, ~digits=4);
------------------------------------------
Указание типов параметров

Чтобы аннотировать функцию, поставьте после каждого параметра двоеточие: и тип данных для этого параметра. После закрывающей скобки параметров поставьте еще одно двоеточие и тип возвращаемого значения функции.
let avg = (a: float, b: float) : float => {...};
let payment = (~principal: float, ~apr: float, ~years: int=30, ():unit) : float=> {...};
или короче:
let avg: (float, float) => float = (a, b) => {...};
let payment: (~principal: float, ~apr: float, ~years: int=?, unit) => float = (~principal, ~apr, ~years = 30, ()) => { ... };
===========================================
Написание функций без параметров или возвращаемых значений стр 25

let random1 = Js.Math.random();
вернёт 0.03326409915331441
let random2 = Js.Math.random; без скобок
привяжет выражение к символу random2 и вернёт [Function: random2]

Возврат unit облегчит отладку
let debugInt = (varName: string, value: int) : unit => {...};

У этой функции нет ни входных параметров, ни возвращаемого типа:
let separator = () : unit => {
	Js.log("---------------");
};

эта функция не делает ничего
let doNothing = (): unit => {
	();
};
===============================================
Каррирование: обработка одного аргумента за раз

При вызове функции ReasonML с меньшим количеством параметров, чем ожидалось, ReasonML не пытается вызвать функцию. Вместо этого он выполняет каррирование автоматическа - он возвращает нам новую функцию с заполненными аргументами и пробелом для остальных параметров.
-----------------------------------------------
Каррирование и значения по умолчанию
При карировании надо избегать подобной маркировки аргументав
let amount = payment(~principal=10000.0, ~apr=5.0);
Если есть позиционный (немаркированный) аргумент, то это полный вызов со значением по умолчанию. В противном случае это карри.
-----------------------------------------------
Каррирование и помеченные параметры

Вместо того, чтобы иметь одну функцию с одним значением по умолчанию, каррирование позволяет создавать несколько функций с разными значениями для одного или нескольких параметров.





