Глава 1 Быстрое освоение Node.js 8  стр 1
Глава 2 Проблемы с файловой системой стр 11
разработка простых программ, которые следят за изменениями файлов и считывают аргументы из командной строки
/code/node8/ch2/
--------------------------------------
- 'use strict' - отключает некоторые проблемные функции языка JavaScript и заставляет другие генерировать исключения
- const - должно быть присвоено значение при объявлении, и ему больше никогда не может быть присвоено что-либо
- let объявляет переменную, но такую, которой можно было бы присвоить значение более одного раза
- require ('fs') - включает встроенный модуль файловой системы Node.js
- метод watch() модуля fs - принимает путь к файлу и функцию обратного вызова, которая вызывается всякий раз, когда файл изменяется

Эта команда будет касаться целевого файла каждую секунду, пока вы ее не остановите:
$ watch -n 1 touch target.txt
----------------------------------------
Чтение аргументов командной строки:
Пример:
const filename = process.argv[2]
если вызвать в консоли
$ node watcher-argv.js target.txt
в filename придёт значение target.txt, второе после node
-----------------------------------------
Создание дочернего процесса
require ('child_process') возвращает модуль дочернего процесса
пример:
const spawn = require('child_process').spawn;
() => {
const ls = spawn('ls', ['-l', '-h', filename]);
ls.stdout.pipe(process.stdout);
}
вернёт в консоль
-rw-r--r-- 1 exc exc 26 мар 17 21:09 target.txt
Первый параметр spawn () - это имя программы, которую мы хотим выполнить; в нашем случае это ls. Второй параметр - это массив аргументов командной строки. Он содержит флаги и целевое имя файла.
Объект, возвращаемый функцией spawn(), является ChildProcess. Его свойства stdin, stdout, nd stderr - это потоки, которые можно использовать для чтения или записи данных. Мы хотим отправить стандартный вывод дочернего процесса прямо в наш собственный стандартный поток вывода. Это то, что делает метод pipe ().
-----------------------------------------
Захват данных от EventEmitter
Иногда вам нужно захватить данные из потока, а не просто пересылать их по конвейеру.EventEmitter предоставляет канал для отправки событий и уведомления слушателей.

- Класс Stream наследуется от EventEmitter, мы можем прослушивать события из стандартного потока вывода дочернего процесса:
const ls = spawn('ls', ['-l', '-h', filename]);
- Buffer - это способ представления двоичных данных в Node.js. Размер буферов нельзя изменить, и они требуют кодирования и декодирования для преобразования в строки JavaScript и из них.
let output = ''
- on() добавляет слушателя для указанного типа события
- События 'data' проходят через объект Buffer. Каждый раз, когда мы получаем кусок данных, мы добавляем его к нашему выводу.
ls.stdout.on('data', chunk => output += chunk);
- После того, как дочерний процесс завершился и все его потоки были сброшены, он генерирует событие 'close', которое тоже прослушивается on(): 
ls.on('close', () => { ...})
-------------------------------------
Асинхронное чтение и запись файлов

Самый простой патерн чтения из файла:
const fs = require('fs')
fs.readFile('file.txt', (err, data) => {...})
Самый простой способ писать в файл:
fs.writeFile('file.txt', 'hello file', (err) => {...})
 
Создание потоков чтения и записи
- с помощью fs.createReadStream () и fs.createWriteStream () соответственно.
- простой скрипт чтения в поток
#!/usr/bin/env node
'use strict';
require('fs').createReadStream(process.argv[2]).pipe(process.stdout);

Блокирование цикла событий с помощью синхронного доступа к файлам:
Многие методы в модуле fs также имеют синхронные версии. Они заканчиваются на * Sync, например, как readFileSync:
const fs = require('fs');
const data = fs.readFileSync('target.txt');
process.stdout.write(data.toString());

Выполнение других операций с файловой системой
POSIX - это семейство стандартов для взаимодействия между
операционные системы, copy(), unlink(), delete(), chmod(), mkdir() и тд.

Две фазы программы Node.js
- На этапе инициализации программа настраивается, вводит библиотеки, считывает параметры конфигурации и выполняет другие критически важные задачи.
- Вторая фаза - это фаза работы, когда программа переходит в цикл обработки событий. Поскольку многие программы Node.js объединены в сеть, это означает прием соединений, выполнение запросов и ожидание других видов ввода-вывода.




















