IO.puts("Look out bekow!")

экранирование \
конкатенация "el" <> "ixir"
интерполяция IO.puts("#{n} yields #{result}.") выполняется один раз
"y is now #{inspect y}" когда не строковое значение интерполируется
операторы сравнения строк ==, === (простое и строгое) "el" == "il"

Многострочные строки(heredocs)
iex(1)> multi = """
...(1)> This is a multiline
...(1)> string, also called a heredoc.
...(1)> """

Юникод
String.length/1 возвращает количество графем Юникода
str = "Экибастуз"
String.length(str)   вернёт 9
byte_size(str) вернёт 18

Списки символов
применяют для совмещения с Erlang, работают медленнее, обрзуются  одинарными кавычками x = 'ixir'
конкатенация 'el' ++ 'ixir'
список в строку
List.to_string('elixir')
строку в список
String.to_char_list("elixir")

Строковые метки (string sigils) сообщают интерпретатору: «Это содержимое должно иметь указанный тип».
начинаются с символа тильды ~, за которым следует буква: 
s (двоичная строка), 
c (список символов), 
r (регулярное выражение),
w (список слов).
S,C,R,W - строка создается в точности без экранирования и интерполяции
После буквы, помимо двойных кавычек, для ограничения строки можно использовать
слеши, квадратные скобки, вертикальную черту (|), круглые скобки, фигурные скобки и угловые скобки.
pass_through = ~S"This is a {#msg}, she said.\n This is only a {#msg}."
~w/Eli­xir is great!/

Ввод символов
IO.getn("Which? > ") дает возможность принять несколько символов от пользователя
В первом аргументе ей передается строка приглашения к вводу, а во втором – количество символов для ввода, по умолчанию 1.
IO.gets возвращает всю строку, введенную пользователем
answer = IO.gets("Which? > ")

String.first(str)
String.strip(str)
String.to_integer(str)
