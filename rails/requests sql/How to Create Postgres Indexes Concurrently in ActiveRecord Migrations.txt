По умолчанию Postgres блокирует запись (но не чтение) в таблицу при создании для нее индекса. Это может привести к недопустимому простою во время производственного развертывания. Индексация большой таблицы может занять несколько часов.
В Postgres есть опция CONCURRENTLY для CREATE INDEX, которая создает индекс, не предотвращая одновременные операции INSERT, UPDATE или DELETE в таблице.

Чтобы упростить использование этого параметра при миграциях, ActiveRecord 4 представил параметр:: concurrently для add_index.

Вот пример:

class AddIndexToAsksActive < ActiveRecord::Migration
  disable_ddl_transaction!

  def change
    add_index :asks, :active, algorithm: :concurrently
  end
end

Предостережение заключается в том, что параллельные индексы должны создаваться вне транзакции. По умолчанию миграции ActiveRecord выполняются внутри транзакции.

Новый disable_ddl_transaction в ActiveRecord 4! Следовательно, метод должен использоваться в сочетании с алгоритмом:: одновременные миграции (как показано выше).

Файл disable_ddl_transaction! применяется только к этому файлу миграции. Смежные миграции по-прежнему выполняются в своих собственных транзакциях и автоматически откатываются в случае сбоя. Поэтому рекомендуется изолировать одновременные миграции индексов в их собственные файлы миграции.

Используйте эту технику с ActiveRecord 4 для одновременного создания индексов Postgres и избежания случайных простоев, вызванных долгой индексацией базы данных с блокировкой записи.
