Help:
erl -man list 
------------------------------------------------------
Нюансы и нюансики:
false и true атомы 0 == false вернёт false, 1 < false вернёт true
term - любое значение в Erlang
можно сравнивать всё со всем: правильный порядок любых элементов в сравнении:
числа < аtoмы < ссылочные значенмя < функции < порты < идентивикаторы процессов < кортежи < спискм > двоичные данные
В Erlang  нет такой вещи, как строка!
-------------------------------------------------------
Console:
erl  , выход q() (ctrl+c)
ctrl+a, ctrl+e  в начало, конец строки
Ctrl+g -->h список команд переключения
-->i -->c  прервать исаолняемую команду и вернуться 
-->j скисок исполняемых процесов
-->k завершить принудительно
-->q выйти

f(). , f(NameValue). стереть перменную (в консоли только)
io:format(os:cmd(clear)). чистить консоль
------------------------------------------------------
Взлёт посадка:

2+2. точка в конце!!!
5 div 2. целочисленное деление
5 rem 2. целочисленный остаток
2#101010 основание#число (сист исчисл для цч)

Переменные неизменяются в функц программировании:
One.
One = 1.
One = One + 1.  error
= cравнивает значения слева и справа
two = 2. error с мал буквы, допустимо _ в начале, для незначимой переменной

Атомы:

atom.
atoms_rule@erland.
'Atoms can be cheated'.
atom = 'atom'.

Атом должен быть в ('') если он не начинается со строчной буквы, или содепжит либые другие символы, кроме букв, цифр, (_), @.

Булева алгебра:

true and false.     - false
false or true.      - true
true xor false.     - true
not false.          - true
not(true and true). - false

andalso, orelse быстрые операторы, проверяют правый аргумент если он нужен

Проверка равенства, неравенства  =:=, =/=
5 =:= 5.   - true точное сравнение
1 =/= 0.   - true
5 == 5.0.  - true  не точное сравнение
5 /= 5.0.  - false

Операторы <,>, >=, =< (=< меньше-равно перевёрнут !!!)

Кортежи - способ организовать данные и сгруппировать множество значений, когда точно известно их количество.
{Элемент1, Элемент2, ... , ЭлементN}
кортеж с тегом, содержит атом и один дополнительный элемент
{point,{X,Y}}.

Списки:
[Элемент1, Элемент2, ... , ЭлементN]
[1,2,3, {numbers, [4,5,6]}, 5.34, atom]
[97,98,99]. вернёт "abc"
Erlang будет печатать списки чисел как числа, когда хотябы одно из низ не может представлять букву !!!

++, -- склеивание, удаление из списка операторы 
[1,2,3]++[4,5]
[1,2,3] -- [1,2] -- [2] вергёт [2,3] выполняются справа налево

голова списка - первый элемент
hd([1,2,3,4]). -> [1]
хвост списка - остаток после головы
tl([1,2,3,4]). -> [2.3.4]
NewList = [1 | List]  - присоединение головы к списку
[Head | Tail ] = List

Обератор |, конструктор в  функц языках
Любой список можно построить по вормуле [ Term1 | [Term2 | [ ... | TermN]]]

{x ϵ R : x=x**2} множество действительных чисел, равное собстенному квадрату

Генератор списка:
множество {2n : n ϵ L }, где L - список [1,2,3,4], для всех значений n в списке [1,2,3,4] дай мне n*2
[2*N || N <- [1,2,3,4]]. на Erlang
Ограничители в генераторах списков
[X || X <- [1,2,3,4,5,6,7,8,9,10], X rem 2 =:= 0]. - выбрать чётные
Схема генераторов:
NewList = [ Выражение || Образец <- Список, Условие1, ... УсловиеN{]}}.
Пример:
RestaurantMenu = [ {steak, 5.99}, {beer, 3.99}, {poutine, 3.50}, {ketten, 20.99}, {water, 0.00}].
[{Item, Price*1.07} || {Item, Price} <- RestaurantMenu, Price >=3, Price =< 10].                 

несколько генераторов
[X+Y || X <- [1,2], Y <- [2,3]]. выполнит 1+2, 1+3, 2+2, 2+3
[3,4,4,5]
Схема:
NewList = [ Выражение || Генератор1, Генератор2, ..., ГенераторN, Условие1, Условие2, ..., УсловиеN{]}}.
Пример:
Weather = [{toronto, rain}, {montreal, storms}, {london, fog}, {paris, sun}, {boston, fog}, {vancouver, snow}].
FoggyPlaces = [X || {X, fog} <- Weather].
-------------------------------------------------
Двоичные данные:

Схранить щранжевый паксель в 24-битном формате
Color = 16#F09A29.
Pixel = <<Color:24>>

Сравнение двоичных данных с шаблонами для распаковки содержимого
Pixels = <<213,45,132,64,76,32,76,0,0,234,32,15>>.
<<Pix1:24,Pix2:24,Pix3:24,Pix4:24>>=Pixels.       
<<R:8, G:8, B:8>> = <<Pix1:24>>.
R.    достали первый пиксель
запись <<Pattern, Rest/binary>> для двоичных данных тоже что и [head | tail]
<<R:8, Rest/binary>> = Pixels.
R.

Двоичные строки:
<<"this is a binary string!"'>>.

Двоичные генераторы:
[X || <<X>> <= <<1,2,3,4,5>>, X rem 2 == 0 ].
RGB = [{R,G,B} || <<R:8,G:8,B:8>> <= Pixels ].

