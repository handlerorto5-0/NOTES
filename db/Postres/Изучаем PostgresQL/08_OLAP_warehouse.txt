Глава 8 OLAP и хранилища данных стр 224 

Обычно база данных настраивается для работы в одном из двух режимов: оперативной транзакционной обработки (online transaction processing – OLTP) и оперативного анализа данных (online analytical processing – OLAP).
--------------------------------------
Извлечение, преобразование и загрузка
extract, transform, load – ETL

Например, задача о загрузке журналов HTTP-доступа в базу данных и под-
готовки их для анализа.
Строки в журналах выгдядят примерно так:
94.31.90.168 - - [01/Jul/2017:01:00:22 +0000] "GET / HTTP/1.1" 200 227 "-""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, likeGecko) Chrome/55.0.2883.87 Safari/537.36"
В базе данных имеется таблица dwh.access_log с такой структурой:
CREATE TABLE dwh.access_log
(
	ts timestamp with time zone,
	remote_address text,
	remote_user text,
	url text,
	status_code int,
	body_size int,
	http_referer text,
	http_user_agent text
);

PostgreSQL позволяет быстро загрузить в таблицу данные – не построчно,
как в команде INSERT, а сразу много строк. Это делается командой COPY.
Данные можно брать из файла, физически находящегося на сервере базы данных в любом месте, доступном процессу PostgreSQL, или из потока. По умолчанию данные должны быть представлены в виде списка полей, разделенных знаками табуляции, а записи должны быть разделены знаками новой строки.
Синтаксис COPY:
COPY <table name> [(column [, ...])] FROM { <file name> | STDIN } [[WITH] (<options>)]
* options задает формат данных: разделители, виды кавычек, символы
экранирования и некоторые другие параметры
* STDIN, данные читаются не из файла, а из стандартного ввода

Пример:
COPY dwh.access_log FROM '/tmp/access.log';
или через командную строку и STDIN:
$ cat access.log | psql -h localhost -U car_portal_app -d
car_portal -c "COPY dwh.access_log FROM STDIN WITH (format csv, delimiter ';')"
или из оболочки psql:
\copy dwh.access_log FROM 'access.log' WITH csv delimiter ';'
---------------------------------------
Моделирование данных для OLAP

Таблица фактов содержит данные для онализа.
Справочная таблица для преобразования идентификаторов.

Данные нередко подвергают денормализации. На практике это озна­чает, что соединение таблиц производится заранее и результат сохраняется в новой таблице.
------------------------------------
Агрегирование
Данные группируются по полям измерений, а поля показателей агрегируют-
ся.
-------------------------------------
Секционирование

Необходимо хранить свежие, часто запрашиваемые данные в одной
сравнительно небольшой таблице, а старые – в другой таблице или в нескольких таблицах, и опрашивать только ту таблицу, в которой находятся данные за интересующий период.

PostgreSQL предлагает способ хранить данные в разных таблицах, но ис-
пользовать общее имя в запросах к ним, с помощью механизма наследования таблиц. При запросе к родительской таблице возвращаются данные из
всех дочерних таблиц(секций).

Секционный ключ -  поле или выражение (или список таковых), значение которого определяет, какой секции принадлежит запись.

--
Секционирование по диапазонам означает, что секции принадлежат все значения из некоторого диапазона.
Пример:
Создать родительскую таблицу, поле ts ключ:
CREATE TABLE dwh.access_log_partitioned (ts timestamptz, url text, status_code int)
PARTITION BY RANGE (ts);
Создать секции для трех диапазонов значений поля ts: июль, ав-
густ, сентябрь 2017:
CREATE TABLE dwh.access_log_2017_07 PARTITION OF dwh.access_log_partitioned
FOR VALUES FROM ('2017-07-01') TO ('2017-08-01');
CREATE TABLE dwh.access_log_2017_08 PARTITION OF dwh.access_log_partitioned
FOR VALUES FROM ('2017-08-01') TO ('2017-09-01');
CREATE TABLE dwh.access_log_2017_09 PARTITION OF dwh.access_log_partitioned
FOR VALUES FROM ('2017-09-01') TO ('2017-10-01');
Теперь мы можем вставлять данные в родительскую таблицу access_log_partitioned, и они будут автоматически попадать в нужные
секции в зависимости от значения секционного ключа.
Что бы можно было вставлять строку, которая никуда не попадает, пользуют MAXVALUE и MINVALUE:
CREATE TABLE dwh.access_log_min PARTITION OF dwh.access_log_partitioned
FOR VALUES FROM (MINVALUE) TO ('2017-07-01');
--
Секционирование по списку.
Например, для кода состояния HTTP можно следующим образом объединить обе
схемы секционирования, создав подсекции для существующих секций:
CREATE TABLE dwh.access_log_2017_10 
PARTITION OF dwh.access_log_partitioned
FOR VALUES FROM ('2017-10-01') TO ('2017-11-01')
PARTITION BY LIST (status_code);
подтаблицы
CREATE TABLE dwh.access_log_2017_10_200 
PARTITION OF dwh.access_log_2017_10
FOR VALUES IN (200);
CREATE TABLE dwh.access_log_2017_10_400 
PARTITION OF dwh.access_log_2017_10
FOR VALUES IN (400);
--
Схему секционирования можно определять не по полю, а по выражению.
В следующем примере секции создаются по первой цифре кода состояния:

CREATE TABLE dwh.access_log_2017_11 PARTITION OF dwh.access_log_partitioned
FOR VALUES FROM ('2017-11-01') TO ('2017-12-01')
PARTITION BY LIST (left(status_code::text, 1));
CREATE TABLE dwh.access_log_2017_11_2XX PARTITION OF dwh.access_log_2017_11
FOR VALUES IN ('2');
CREATE TABLE dwh.access_log_2017_11_4XX PARTITION OF dwh.access_log_2017_11
FOR VALUES IN ('4');

========================================
Параллельные запросы стр 236

PostgreSQL создает серверный процесс для каждого клиентского подключе-
ния.
PostgreSQL поддерживает параллельные запросы, т. е. позволяет отдавать
несколько процессоров под один запрос.

Оключение паралельных запросов:
> SET max_parallel_workers_per_gather = 0;
Включение паралельных запросов:
> SET max_parallel_workers_per_gather = 1;
========================================
Просмотр только индексов

Если вся информация, необходимая для выполнения запроса, содержится в индексе, то сервер не станет просмат­ ривать данные в таблице, а ограничится индексом.

ОТключить эту функцию:
> SET enable_indexonlyscan = off;

* Не все индексы поддерживают механизм просмотра. Индексы типа B-tree
поддерживают его всегда, типа GiST и SP-GiST – только для некоторых операторов, а типа GIN не поддерживают вовсе.












