==================================
Сложные типы данных

Команды SET начинаются с S, хэши с H, а отсортированные наборы с Z. Команды списка обычно начинаются либо с L (слева), либо с R (справа), в зависимости от направления операции (например, LPUSH).
----------------------------------
Хеш
* хеши могут хранить только строковые значения
* двоеточие внутри ключей часто логически разделяет ключ на сегменты

> MSET user:luc:name "Luc" user:luc:password s3cret
> MGET user:luc:name user:luc:password

Вместо отдельных ключей мы можем создать хеш, содержащий собственные пары ключ-значение.
> HMSET user:luc name "Luc" password s3cret
> HVALS user:luc
> HKEYS user:luc
> HGET user:luc password

Примеры дополнительных команд:
- удалить хеш-поля (HDEL)
- увеличить значение целочисленного поля на некоторое количество (HINCRBY)
- получить количество полей в хеше (HLEN)
- получить все ключи и значения (HGETALL)
- установить значение, только если ключ еще не существует (HSETNX)
------------------------------------
Списки
Команды списка начинаются либо с L (слева), либо с R (справа)
- LPUSH и RPOP для очереди
- LPUSH и LPOP для стека

Списки содержат несколько упорядоченных значений, которые могут действовать как очереди (fifo), так и стеки (lifo).

> RPUSH eric:wishlist 7wks gog prag
* LRANGE - получить любую часть списка, указав первую и последнюю позиции
> LRANGE eric:wishlist 0 -1
* LREM удаляет из данного ключа некоторые совпадающие значения.
* Установка счетчика больше 0 удалит только это количество совпадений, а установка счетчика на отрицательное число удалит это количество совпадений, но просканирует список с конца (с правой стороны).
> LREM eric:wishlist 0 gog
* можно вытащить их из левого (верхнего) списка
> LPOP eric:wishlist

* Redis предоставляет одну команду для извлечения значений
от конца одного списка и толкание в начало другого - RPOPLPUSH (правый поп, левый толчок).
--------------------------------
Блокирование списков
BRPOP - команда для блокировки до тех пор, пока не появится значение для извлечения:
> BRPOP comments 300

BLPOP удалит первый элемент в списке или блоке (точно так же, как BRPOP удалил последний элемент), а BRPOPLPUSH - это блокирующая версия RPOPLPUSH
-------------------------------
Sets

Множества представляют собой неупорядоченные коллекции без повторяющихся значений и являются отличным выбором для выполнения сложных операций между двумя или более ключевыми значениями, такими как объединения или пересечения.

* можно добавить несколько значений
> SADD news nytimes.com pragprog.com
> SADD tech pragprog.com apple.com
* получить полный набор в произвольном порядке
> SMEMBERS news
* найти пересечение множеств, есть в обоих
> SINTER news tech
* найти все новостные сайты, не относящиеся к техническим
> SDIFF news tech
* обьединить, дубликады будут удалены
> SUNION news tech
* обьединить и сохранить в новом множестве
> SUNIONSTORE websites news tech

- для хранения пересечений (SINTERSTORE) и различий (SDIFFSTORE)
- SMOVE перемещает значения из одного набора в другой
- SCARD находит длину наборов
- SPOP - извлечение случайного значения из набора
- SREM key value [value ...] удаление значений
----------------------------------------
Sorted Sets
Упорядоченные множества упорядочены, как списки, и уникальны, как множества. У них есть пары «поле-значение», такие как хэши, но их поля представляют собой числовые оценки, которые обозначают порядок значений, а не простые строки. Вы можете думать о сортированных наборах как о очереди с приоритетом произвольного доступа.

Мы хотим отслеживать популярность конкретных шорткодов. Каждый раз, когда кто-то посещает URL-адрес, оценка увеличивается. Как и хэш, для добавления значения в отсортированный набор требуется два значения после имени ключа Redis: оценка и член.
> ZADD visits 500 7wks 9 gog 9999 prag
для увеличения счетчика
> ZINCRBY visits 1 prag
для уменьшения счетчика
> ZINCRBY visits 1 prag
-------------------------------------
Ranges  стр 268

Диапазоны. 

- ZRANGE - возвращает значение по позиции
> ZRANGE visits 0 1
- Чтобы получить оценки для каждого элемента, добавьте WITHSCORES к предыдущему коду. Чтобы получить их наоборот, вставьте слово REV, как в ZREVRANGE.
> ZREVRANGE visits 0 -1 WITHSCORES
- ZRANGEBYSCORE возвращает диапзон, по умолчанию включены крайние 9 <= score <= 10,000:
> ZRANGEBYSCORE visits 9 9999
- отключены крайние 9 < score <= 10,000:
> ZRANGEBYSCORE visits (9 99991)
- как положительные, так и отрицательные значения, включая бесконечности
> ZRANGEBYSCORE visits -inf inf
- то же в обратном порядке:
> ZREVRANGEBYSCORE visits inf -inf

- ZREMRANGEBYRANK и ZREMRANGEBYSCORE соответственно удаляют значения по рангу или баллу
-------------------------------------------
Unions
Мы можем создать целевой ключ, содержащий объединение или пересечение одного или нескольких ключей.

Операция объединения выглядит так:

ZUNIONSTORE destination numkeys key [key ...]
[WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]

* destination - это ключ к хранению
* key - один или несколько ключей к объединению
* numkeys - это просто количество ключей, к которым вы собираетесь присоединиться
* weight - необязательное число для умножения каждой оценки относительного ключа (если у вас есть два ключа, у вас может быть два веса и т. д.)
* aggregate - это необязательное правило для определения каждой взвешенной оценки и суммирования по умолчанию, но вы также можете выбрать минимальное или максимальное значение для множества оценок.

Пример.Мы хотим сложить два типа оценок вместе, чтобы вычислить новую оценку важности, при этом придав голосам удвоенный вес - умноженный на два.
> ZUNIONSTORE imp 2 visits votes WEIGHTS 1 2 AGGREGATE SUM
если вам нужно удвоить все оценки набора, вы можете объединить один ключ с весом 2 и сохранить его обратно в себя.
> ZUNIONSTORE votes 1 votes WEIGHTS 2
-----------------------------------------
Expiry

- EXPIRE помечает ключ как истекающий, тоебуется передать, существующий ключ и время жизни (в секундах). 
- EXISTS проверяет, является ли ключ  истекающим в течение десяти секунд, возвращает 1 (истина).
> SET ice "I'm melting..."
> EXPIRE ice 10
> EXISTS ice

- SETEX для короткой записи команды
> SETEX ice 10 "I'm melting..."

- TTL время оставшейся жизни, в миличекундах, усли истекло аосзвращает время с момента истечения с минусовым знаком
> TTL ice

- PERSIST в любой момент до истечения срока действия ключа, может удалить тайм-аут
> PERSIST ice

Для отметки обратного отсчета до определенного времени EXPIREAT принимает временную метку Unix (в секундах с 1 января 1970 года), а не количество секунд, до которых нужно отсчитывать время. Другими словами, EXPIREAT предназначен для абсолютных тайм-аутов, а EXPIRE - для относительных тайм-аутов.
Распространенный прием для хранения только недавно использованных ключей - обновлять время истечения срока действия всякий раз, когда вы извлекаете значение. Это последний использованный алгоритм кэширования (MRU), гарантирующий, что ваши последние использованные ключи останутся в Redis, в то время как неиспользованные ключи просто истекут как обычно.
