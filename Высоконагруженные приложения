стр 71
декларативные языки часто хорошо подходят для параллельного выполнения. Сегодня ускорение CPU происходит за счет добавления дополнительных ядер, а не повышения тактовой частоты. Распараллелить императивный код по нескольким ядрам и нескольким машинам очень непросто, поскольку в нем задается определенный порядок выполнения команд. Шансы декларативных языков на ускорение за счет параллельного выполнения выше, поскольку они задают лишь шаблон результатов, а не используемый для их получения алгоритм. База данных при желании может задействовать параллельную реализацию языка запросов

стр 78 
три декларативных языка запросов для графов: Cypher, SPARQL и Datalog. Кроме них, существует императивный графовый язык запросов под названием Gremlin и фреймворк для работы с графами — Pregel

стр 97
Wer Ordnung ha lt, ist nur zu faul zum Suchen.
(Если вы поддерживаете в вещах порядок, значит, вы
просто слишком ленивы, чтобы их искать.)
Немецкая поговорка

стр 98
БД в виде двух функций командной оболочки Bash:
#!/bin/bash
db_set () {
	echo "$1,$2" >> database
}
db_get () {
	grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}
Обе функции реализуют хранилище типа «ключ — значение». Можно вызвать команду db_set key value для сохранения key и value в базе данных. Ключ и значение могут быть (почти) всем, чем вы пожелаете, — например, значение может быть JSON-документом. Затем можно вызвать команду db_get key для поиска последнего относящегося к искомому ключу значения и его возврата:
$ db_set 123456 '{"name":"London","attractions":["Big Ben","London Eye"]}'
$ db_set 42 '{"name":"San Francisco","attractions":["Golden Gate Bridge"]}'
$ db_get 42
{"name":"San Francisco","attractions":["Golden Gate Bridge"]}

стр 123
Выделяют Системы обработки транзакций (OLTP) и Аналитические системы (OLAP) Склад данных (data warehouse), представляет собой отдельную БД, которую аналитики могут опрашивать так, как им заблагорассудится.Процесс помещения дaнных в склад известен
под названием «извлечение — преобразование — загрузка» (extract — transform — load, ETL) Алгоритмы индексации отлично работают для OLTP, но не так хороши при выдаче ответов на аналитические запросы.
Склады данных: Apache Hive, Spark SQL, Cloudera Impala, Facebook Presto, Apache Tajo и Apache Drill


стр 133
запросы к складам часто включают функции агрегирования, такие как COUNT , SUM , AVG , MIN или MAX в языке SQL
Один из способов создания их кэша — материализованное представление (materialized view).
Материализованное представление является фактической копией результатов запроса, записанной на диск, в то время как виртуальное представление — просто сокращенная форма записи для написания запросов


стр 144
форматы кодирования данных: JSON, XML, Protocol Buffers, Thrift и Avro
Преобразование из представления в памяти в последовательность байтов называется кодированием (encoding), или сериализацией (serialization), или маршалингом (marshalling), а обратная ему операция — декодированием (decoding), или парсингом (parsing), или десериализацией (deserialization), или демаршалингом (demarshalling)
Встроенная поддержка кодирования объектов из памяти в последовательности байтов в языке Ruby — Marshal

стр 154
Avro тоже(как и Protocol Buffers, Thrift) применяет схему для задания структуры кодируемых данных. В нем есть два языка описания схем: один (Avro IDL) предназначен для редактирования людьми, а второй (основанный на формате JSON) лучше подходит для считывания компьютерами.
у Avro самое компактное кодирование - 32 байта
Если работающему с Avro приложению необходимо кодировать какие-либо данные (чтобы записать их в файл или БД, отправить по сети и т. п.), то оно декодирует их на основе writer’s schema.
Если приложению необходимо декодировать какие-либо данные (прочитать их из файла или БД, получить их по сети и т. п.), оно ожидает reader’s schema

стр 166
Существует два популярных подхода к проектированию веб-сервисов: REST и SOAP.
REST не протокол, а скорее подход к проектированию, основанный на принципах HTTP. Он делает акцент на простых форматах данных, применении URL для идентификации ресурсов и использовании возможностей HTTP для управления кэшем, аутентификации и согласования типа контента.
SOAP — основанный на формате XML протокол для выполнения запросов к сетевым API.
API SOAP web services description language,WSDL позволяет генерировать код, так что клиент может обращаться к удаленным сервисам путем локальных классов и вызовов методов.

Основная идея модели RPC состоит в том, что выполнение запроса к удаленному сетевому сервису должно выглядеть
так же, как и вызов функции или метода на обычном языке программирования, в пределах одного процесса


стр 171
системы асинхронной передачи сообщений
запрос от клиента (message) доставляется другому процессу без особой задержки. проходит через посредника, именуемого брокером сообщений (message broker)
один процесс отправляет сообщение, предназначенное для определенной очереди (queue) или дискуссии (topic), а брокер обеспечивает доставку данного сообщения одному или нескольким потребителям (consumers) или подписчикам (subscribers) этой очереди или дискуссии. В одной дискуссии может быть много инициаторов (producers) и много потребителей сообщений.

асинхронная передача сообщений (с помощью брокеров сообщений или акторов), где узлы взаимодействуют путем отправки друг другу сообщений, кодируемых отправителем и декодируемых получателем.

стр 181
Архитектуры без разделения ресурсов(shared-nothing architectures), известные под названием горизонтального масштабирования (horizontal scaling, scaling out). При этом подходе каждый компьютер или виртуальная машина, на которой работает база данных, называется узлом (node). Все узлы используют свои CPU, память и диски независимо друг от друга. Согласование узлов выполняется на уровне программного обеспечения с помощью обычной сети.
- Репликация. Копии одних и тех же данных хранятся в нескольких различных узлах, вероятно располагающихся в разных местах.
- Секционирование. Разбиение большой базы данных на небольшие подмножества, называемые секциями (partitions)

репликацией с ведущим узлом (leader-based replication):
- Одна из реплик назначается ведущим  (leader) узлом. Клиенты, желающие записать данные в базу, должны отправить свои запросы ведущему узлу
- Другие реплики называются ведомыми (followers) узлами. Всякий раз, когда ведущий узел записывает в свое хранилище новые данные, он также отправляет информацию об изменениях данных всем ведомым узлам в качестве части журнала репликации (replication log) или потока изменений (change stream).

На практике активизация в СУБД синхронной репликации обычно означает, что один из ведомых узлов — синхронный, а остальные — асинхронны.
 
создать ведомый узел:
- Сделать согласованный снимок состояния БД ведущего узла на определенный момент времени
- Скопировать снимок состояния на новый ведомый узел.
- Ведомый узел подключается к ведущему и запрашивает все изменения


стр 239
Секционирование. 
В случае очень больших наборов данных или объемов обрабатываемой информации, необходимо разбить данные на секции (partitions), иначе говоря, выполнить шардинг (sharding) данных. Цель секционирования — равномерно распределить по узлам данные и загрузку
по запросам.

Секционирование данных типа «ключ — значение»
Один из методов секционирования — назначить каждой из секций непрерывный диапазон значений ключа (от какого-то минимального значения до какого-то максимального), подобно томам бумажной энциклопедии.

Секционирование по хешу ключа
Object#hash в Ruby могут возвращать различные значения хеша для одного ключа в разных процессах .можно поставить каждой
секции в соответствие диапазон хешей (вместо диапазона ключей), и каждый ключ, чье значение находится в диапазоне данной секции, будет сохранен в ней.

Процесс перемещения нагрузки с одного узла в кластере на другой называется перебалансировкой (rebalancing).
можно разбить работающую на кластере из десяти узлов базу данных на 1000 секций из расчета по 100 секций на каждый узел.
Тогда добавляемый в кластер новый узел может «позаимствовать» по нескольку секций у каждого из существующих узлов на время, до тех пор пока секции не станут снова распределены равномерно.

стр 255
Маршрутизация запросов
Задача, называемая обнаружением сервисов (service discovery), относится не только к базам данных. Задача касается лю-
бого доступного программного обеспечения, предназначенного для обращения по сети, особенно стремящегося к высокой доступности (при работе на нескольких машинах в избыточной конфигурации).
Многие распределенные информационные системы используют для отслеживания этих метаданных кластера отдельный сервис координации, например ZooKeeper.


стр 265
Транзакции
Системы, не соответствующие критериям ACID, иногда называются BASE, что расшифровывается следующим образом: «как правило, доступна» (Basically Available), «гибкое состояние» (Soft state) и «конечная согласованность» (Eventual consistency). Это понятие еще более расплывчатое, чем ACID. Похоже, единственное разумное определение BASE — «не ACID», то есть оно может значить практически все что угодно.

- Атомарность определяется как «невозможность разбиения на меньшие части». Возможность прервать транзакцию при ошибке и игнорировать все ее операции записи — отличительная черта атомарности ACID.
- Согласованность, в ACID состоит в том, что определенные утверждения относительно данных (инварианты) должны всегда оставаться справедливыми — например, в системе бухгалтерского учета кредит всегда должен сходиться с дебетом по всем счетам.
Формулировать транзакции таким образом, чтобы сохранялась согласованность, — обязанность приложения.
- Изоляция в смысле ACID означает, что конкурентно выполняемые транзакции изолированы друг от друга — они не могут помешать друг другу.
- Сохраняемость.На практике не существует ни одного метода, дающего абсолютную гарантию сохраняемости данных. Существуют только различные методики снижения рисков, включая запись на диск, репликацию на удаленные машины и выполнение резервных копий, которые можно и нужно комбинировать.

Для многообъектных транзакций необходимо знать, какие операции записи и чтения относятся к одной транзакции. В реляционных базах данных это можно узнать из TCP-соединения клиента с сервером БД: считается, что все находящееся между операторами BEGIN TRANSACTION и COMMIT конкретного соединения относится к одной транзакции.
Атомарность можно обеспечить с помощью журнала для восстановления после сбоев, а изоляцию — путем блокировок отдельных объектов (благодаря которым обращаться к объекту одновременно может только один поток выполнения).

Отличительная особенность транзакций — возможность их прерывания и безопасного повторного выполнения в случае возникновения ошибки. ActiveRecord не повторяет попытку выполнения прерванных транзакций — ошибка в них обычно приводит к «всплытию» исключения по стеку, так что все введенные пользователем данные теряются, а сам он получает сообщение об ошибке.

Самый базовый уровень изоляции транзакций — чтение зафиксированных данных.
Предотвращфаются «грязных» операций записи, обычно путем откладывания второй операции записи до того момента, когда транзакция первой операции будет зафиксирована или прервана.

Чаще всего базы используют блокировки строк для предотвращения «грязных» операций записи: прежде чем модифицировать конкретный объект (строку или документ), транзакция должна сначала установить блокировку на этот объект.

Изоляция снимков состояния - каждая из транзакций читает данные из согласованного снимка состояния БД, то есть видит данные, которые были зафиксированы в базе на момент ее (транзакции) начала. «чтение никогда не блокирует запись, а запись — чтение» Транзакция использует идентификаторы транзакций, чтобы определить, какие объекты она может видеть, а какие — нет.
Объект является видимым, если: 
- на момент начала выполнения читающей объект транзакции создавшая его транзакция уже зафиксирована;
- объект не помечен для удаления, а если и помечен, то запросившая удаление транзакция еще не была зафиксирована на момент начала выполнения чита­ющей объект транзакции.

стр 288
BEGIN TRANSACTION;
SELECT ... FOR UPDATE; -- указывает бд блокировать все возвращенные запросом строки
-- Проверяем допустимость хода, после чего обновляем возвращенную предыдущим SELECT позицию фигуры.
UPDATE ...
COMMIT;
ActiveRecord  с Postgres добавит FOR UPDATE User.lock.first. Например:
Order.transaction do       
	o1 = Order.lock.first
	o1.update_attributes(name: 'Foo Bar')
end
для предотвращения конкурентной записи применяют проверку условия

стр 297
Эффект, при котором операция записи в одной транзакции меняет результат запроса на поиск в другой, называется фантомом
Причина в отсутствии снимка ещё не созданого объекта. Для лечения исползуют Материализация конфликтов. Например, в случае с бронированием конференц-залов можно было бы создать таблицу отрезков времени и залов и в ней цже блокировать транзакции.

стр 298
Сериализуемость, база предотвращает все возможные состояния гонки.

Подход с последовательным выполнением транзакций реализован в таких СУБД, как VoltDB/H-Store, Redis и Datomic
Инкапсуляция транзакций. Приложение заранее отправляет весь код транзакции в базу данных в виде хранимой процедуры (stored procedure).

Двухфазная блокировка (two-phase locking, 2PL)
Допускается конкурентное чтение одного объекта несколькими транзакциями при условии, что никто его не записывает. Но для выполнения операции записи этого объекта (изменения или удаления) требуется монопольный доступ.

Предикатные блокировки. Oтносится не к конкретному объекту (например, одной строке в таблице),
а ко всем объектам, удовлетворяющим какому-то условию отбора

Блокировки по диапазону значений индекса (index-range lock)

стр 308
Сериализуемая изоляция снимков состояния (serializable snapshot isolation, SSI)
При фиксации транзакции база данных проверяет, не случилось ли чего-то плохого (например, не была ли нарушена изоляция).


стр 333
Проблеммы распределённых систем.

Если на момент достижения пакетом машины получателя все ядра CPU оказываются заняты, то операционная система отправляет входящий сетевой запрос в очередь до тех пор, пока приложение не сможет его обработать.

Логические часы (logical clocks), в основе которых лежит наращивание счетчика, а не колебательный кварцевый генератор, — более надежная альтернатива для упорядочения событий. 
Не имеет смысла рассматривать показания часов как момент времени — это скорее промежуток времени в пределах доверительного интервала.

Узел сети ничего не знает наверняка — он способен только делать предположения на основе получаемых (или не получаемых) им по сети сообщений.
Если удаленный узел не отвечает, то нет никакого способа выяснить его состояние, поскольку невозможно отличить сетевые проблемы от проблем в узле.
Многие распределенные алгоритмы основывают свою работу на кворуме, то есть решении большинства узлов.

стр 374
Лучший способ построить отказоустойчивую систему — создать некоторые общие абстракции с полезными гарантиями, реализовать их один раз, а затем позволить приложениям полагаться на эти гарантии.
Основная цель распределенной согласованности — координировать состояние реплик в усло­виях задержек и сбоев.

Линеаризуемость - снаружи система должна вести себя так, как если бы в ней существовала только одна копия данных: должна быть единая временная шкала, относительно которой все операции полностью упорядочены.
Для сохранения причинности нужно знать, какая операция произошла раньше, а какая — позже.
Временноя метка Лампорта - метод генерации порядковых номеров, это просто пара типа «счетчик, ID узла». Из двух временных меток большей будет та, у которой больше значение счетчика; если значения счетчиков одинаковы, то больше будет метка с большим ID узла.Когда узел получает запрос или ответ со значением счетчика, большим, чем его собственное, он неме­д­ленно увеличивает свой счетчик до этого максимума.

Рассылка общей последовательности - протокол обмена сообщениями между узлами.Если сообщение доставляется одному узлу, то оно доставляется всем узлам. Сообщения доставляются во все узлы в одном и том же порядке.

Консенсус является одной из важнейших и фундаментальных проблем распределенных вычисленийцель состоит в том, чтобы заставить несколько узлов согласовать некие объекты.

стр 413
Двухфазная фиксация гарантирует, что все узлы либо зафиксировали транзакцию, либо прервали ее.

стр 429
HBase, Hadoop YARN, OpenStack Nova и Kafka полагаются на систему ZooKeeper, работающую в фоновом режиме.
ZooKeeper и etcd предназначены для хранения небольших объемов данных, которые полностью помещаются в памяти. Этот небольшой объем реплицируется по всем узлам с помощью отказоустойчивого
алгоритма рассылки общей последовательности.

Система ZooKeeper поддерживает:
- Линеаризуемые атомарные операции.
- Общая последовательность операций.
- Обнаружение сбоев.
- Изменение уведомлений.

=================================
Часть 3. Производные данные стр445

Системы записи(источник правды).Когда появляются новые данные,
они сначала записываются сюда, обычно нормализуется.
Производные информационные системы. Данные в такой системе являются результатом получения неких уже существующих данных из другой системы. Они обычно денормализованы для скорости.

Типы систем:
- Сервисы (онлайновые системы). Сервис ожидает запросов и инструкций, поступающих от клиента. После того как запрос получен, сервис пытается обработать его максимально быстро и возвращает отклик.
- Системы пакетной обработки (автономные системы). Такая система принимает большое количество данных, запускает задачу для их обработки и выдает некие данные на выход.
- Системы поточной обработки (системы почти реального времени). Эта система принимает данные на входе и генерирует выходные данные. В случае появления событий поточные задачи реагируют на них.

MapReduce - алгоритм пакетной обработки, внедрен в Hadoop, CouchDB и MongoDB и пр.. Задача MapReduce подобна процессу Unix: принимает один или несколько потоков ввода и производит один или несколько потоков вывода.
Чтобы создать задачу MapReduce, необходимо реализовать две функции обратного вызова, сопоставление и сжатие:
- Сопоставление. Функция сопоставления вызывается один раз для каждой входной записи, ее задача — извлечь ключ и значение записи.
- Сжатие. Среда разработки MapReduce принимает пары «ключ — значение», созданные функцией сопоставления, объединяет все значения, соответству­ющие одному ключу, и вызывает для каждой такой группы значений функцию сжатия.

Результатом выполнения пакетных задач часто является база данных: например, такая, к которой можно делать запросы по ID пользователя и получать рекомендованных для него друзей, или база, к которой можно делать запросы по ID продукта и получать списки связанных продуктов.

стр 478
Hadoop похожа на распределенную версию Unix с файловой системой HDFS и MapReduce. Hadoop открыла возможность записывать в HDFS любые данные и только потом выяснять, как их обрабатывать. 
--------------------------
Подсистемы потока данных(Spark, Tez), вызывают пользовательскую функцию для обработки каждой записи потока, в них весь рабочий процесс расматривается как одна задача. Можно использовать для тех же вычислений, что и потоки MapReduce

==========================
Потоковая обработка  стр 505































































