OAuth.txt

Руководство по OAuth для начинающих: токены доступа и коды авторизации с помощью Google API

Пользователю легко и удобно использовать свою учетную запись Google (или acebook, Twitter и т. Д.) Для входа в другие службы.

- Вы нажимаете кнопку «Войти через Google»
- Вы будете перенаправлены на экран согласия
- Вы нажимаете "Разрешить"
- Страница перенаправляется на фактическое приложение

Что такое коды авторизации и токены доступа?

В потоке OAuth ваше приложение должно отправить два запроса в Google. Первый запрос - получить код авторизации, второй - получить токен доступа. Оба они имеют форму длинных strings, но имеют разные цели.
Код авторизации - это код, который Google отправляет обратно в ваше приложение после согласия пользователя.
Этот код можно использовать для получения токена доступа. Получив код авторизации, вы помещаете его в params и отправляете второй запрос в Google, по сути говоря: «Дайте мне токен доступа, чтобы я мог отправлять запросы от имени этого пользователя?»
Ответ Google на это должен включать токен доступа. Поместив этот токен в заголовки запросов, вы можете делать такие вещи, как создавать новое событие в календаре Google пользователя или получать доступ к Gmail пользователя.

Ключевые моменты, на которые следует обратить внимание:

Код авторизации вействительно только для одноразового использования, так как его единственное использование - обменять его на токен доступа. Срок действия истекает очень быстро

Токен доступа
Можно получить с помощью кода авторизации
Вставлять заголовки любых запросов API к Google от имени пользователя.
Срок действия истекает через час (срок действия может отличаться, если вы используете что-то помимо Google)
Через час, когда истекает срок действия токена доступа, вы можете получить так называемый токен обновления, который позволяет вам получать новые токены доступа.
---------------------------
Пошаговая инструкция по OAuth

Шаг 1. Пользователь нажимает кнопку «Войти через Google» в вашем приложении.
Шаг 2. Перенаправление на экран согласия Google
В примере нажатие кнопки вызывает метод oauth oauths_controller, который затем перенаправляет страницу.
-
# oauths_controller.rb
def oauth
  args = {
    client_id: ENV['GOOGLE_CLIENT_ID'],
    response_type: 'code',
    scope: 'https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/calendar',
    redirect_uri: 'http://my-app.com/oauth/callback?provider=google',
    access_type: 'offline'
  }
  redirect_to 'https://accounts.google.com/o/oauth2/v2/auth?' + args.to_query
end
-
Параметры:
client_id - это тот, который вы создали в консоли Google API. Я только что сохранил его в переменной окружения.
response_type: 'code' сигнализирует о том, что вам нужен код авторизации для получения токена доступа.
scope - oбласть видимости определяет, какие виды разрешений вам нужны. Мне нужен был доступ к календарю Google пользователя в дополнение к имени пользователя и адресу электронной почты, поэтому у меня есть три области, указанные выше. Полный список областей действия можно найти в документации.
redirect_uri - это URI, на который Google перенаправляет, когда пользователь нажимает «Разрешить». Вы не можете указать здесь случайный URI; он должен соответствовать одному из URI, добавленных вами в консоли Google API.
access_type: "offline" имеет отношение к токенам обновления
Шаг 3. Пользователь нажимает «Разрешить» на экране согласия.
Шаг 4. Страница перенаправляется на ваш callback_uri
Этой частью занимается Google. В моем случае вызывается метод обратного вызова oauths_controller.
# routes.rb
get 'oauth/callback', to: 'oauths#callback'
Параметры этого входящего запроса от Google включают код авторизации  (in params[:code]).
Шаг 5. Обменяйте код авторизации на токен доступа.
Затем вам нужно сделать HTTP-запрос POST к конечной точке токена Google  (/oauth2/v4/token), чтобы получить токен доступа в обмен на только что полученный код авторизации.
Примечание: использование гема HTTParty для выполнения HTTP-запросов, но, конечно, не обязательно.
-
# oauths_controller.rb
def callback
  # Обменять код авторизации на токен доступа (шаг 5)
  query = {
    code: params[:code],
    client_id: ENV['GOOGLE_CLIENT_ID'],
    client_secret: ENV['GOOGLE_CLIENT_SECRET'],
    redirect_uri: 'http://my-app.com/oauth/callback?provider=google',
    grant_type: 'authorization_code'
  }
  response = HTTParty.post('https://www.googleapis.com/oauth2/v4/token', query: query)

  # Сохраните токен доступа (шаг 6)
  session[:access_token] = response['access_token']
end
-
Шаг 6. Сохраните токен доступа.
Как видно из последней части фрагмента выше, используется сохранение возвращенного access_token в сеансе. Теперь запрос к Google API от имени пользователя с использованием этого токена.

Например, чтобы получить список событий Календаря Google пользователя:
-
headers = {
  'Content-Type': 'application/json',
  'Authorization': "Bearer #{session[:access_token]}"
}
HTTParty.get(
  'https://www.googleapis.com/calendar/v3/calendars/primary/events',
  headers: headers
)
-
------------------
Обновите токены, чтобы получить новые токены доступа

Вы можете получить его в том же ответе, что и тот, который возвращает токен доступа (шаг 5), если вы указали access_type: 'offline' в начальном перенаправлении (шаг 2).

В отличие от токенов доступа, у токенов обновления нет установленного срока действия. Если срок действия вашего токена доступа истек, вы можете получить новый, используя токен обновления с запросом HTTP POST, как показано ниже:
-
query = {
  'client_id': ENV['GOOGLE_CLIENT_ID'],
  'client_secret': ENV['GOOGLE_CLIENT_SECRET'],
  # Assuming we've saved the refresh_token in the DB along with the user info
  'refresh_token': current_user.refresh_token,
  'grant_type': 'refresh_token',
}
response = HTTParty.post(
  'https://www.googleapis.com/oauth2/v4/token',
  query: query
)

session[:access_token] = response['access_token']
-
----------------------
подводные камни
1. Google дает токен обновления только при первом согласии пользователя и входе в ваше приложение.

Это означает, что важно хранить токены обновления в долгосрочном хранилище, например в БД.

Примечание. Если вам действительно нужно получать новый токен обновления каждый раз, когда пользователь входит в систему, вы можете добавить prompt=consent к параметрам в запросе авторизации на шаге 2. Это потребует от пользователя согласия каждый раз при входе в систему, но ответ всегда будет включать новый токен обновления.

2. Хотя токены обновления не истекают по прошествии определенного времени, в некоторых случаях они могут стать недействительными:

Вы должны написать свой код, чтобы предвидеть возможность того, что предоставленный токен обновления больше не будет работать. Токен обновления может перестать работать по одной из следующих причин:

Пользователь отозвал доступ вашему приложению.
Токен обновления не использовался в течение шести месяцев.
Пользователь изменил пароли, и токен обновления содержит области Gmail.
В учетной записи пользователя превышено максимальное количество предоставленных (действующих) токенов обновления. В настоящее время существует ограничение в 50 токенов обновления на учетную запись пользователя для каждого клиента. Если предел достигнут, создание нового токена обновления автоматически аннулирует самый старый токен обновления без предупреждения.
Например, если пользователь отозвал доступ к вашему приложению, любые запросы на получение нового токена доступа с использованием существующего токена обновления перестанут работать. В таких случаях вам нужно будет заставить пользователя выйти из системы и повторно войти в систему, чтобы получить новый токен обновления.

Здесь мы обрабатываем все вручную, не полагаясь на gems, такие как devise, sorcery или omniauth-google-oauth2.

